;;; git-revert.el --- Cleanup a git directory

;; Copyright (C) 2011 Sean MacLennan

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;; This program takes a git directory and puts it back into a clean
;; state. It reverts all modified files, deletes all new files, and
;; restores all pending commits.

;; WARNING: The whole point is to get things back to a clean state.

;;                  YOU WILL LOSE ALL CHANGES!



(eval-when-compile (require 'tmp-buffer))

(defvar git-lineno nil "Local to store current line number.")

(defmacro git-bad-line () (list 'error "Bad line %d" 'git-lineno))

(defun git-next-line ()
  (end-of-line)
  (unless (eobp) (forward-char))
  (setq git-lineno (1+ git-lineno)))

;; End of block ;)
(defun git-eob ()
  (or (looking-at "#$")
      (eobp)
      (looking-at "no changes added to commit")
      (looking-at "nothing added to commit but untracked files")
      (git-bad-line)))

;; Unused but tested and works
(defun git-parse-committed ()
  ;; Skip the header
  (git-next-line)
  (unless (looking-at "#   (use \"git reset HEAD <file>...\" to unstage)") (git-bad-line))
  (git-next-line)
  (unless (looking-at "#$") (git-bad-line))
  (git-next-line)

  (let (cmd file reset-list)
    (while (looking-at "#\t\\([a-z ]+\\): +\\(.*\\)")
      (setq cmd (match-string 1) file (match-string 2))
      (unless (or (equal cmd "new file") (equal cmd "deleted")) (git-bad-line))
      (add-to-list 'reset-list file)
      (git-next-line))

    (git-eob)
    reset-list))

(defun git-parse-not-staged ()
  ;; Skip the header
  (git-next-line)
  ;; Catches git add and git add/rm
  (unless (looking-at "#   (use \"git add") (git-bad-line))
  (git-next-line)
  (unless (looking-at "#   (use \"git checkout -- <file>...\" to discard") (git-bad-line))
  (git-next-line)
  (unless (looking-at "#$") (git-bad-line))
  (git-next-line)

  (let (cmd file checkout-list)
    (while (looking-at "#\t\\([a-z ]+\\): +\\(.*\\)")
      (setq cmd (match-string 1) file (match-string 2))
      (unless (or (equal cmd "modified") (equal cmd "deleted")) (git-bad-line))
      (add-to-list 'checkout-list file)
      (git-next-line))

    (git-eob)
    checkout-list))

(defun git-parse-untracked ()
  ;; Skip the header
  (git-next-line)
  (unless (looking-at "#   (use \"git add <file>...\" to include") (git-bad-line))
  (git-next-line)
  (unless (looking-at "#$") (git-bad-line))
  (git-next-line)
  (let (rm-list)
    (while (looking-at "#\t\\(.*\\)")
      (add-to-list 'rm-list (match-string 1))
      (git-next-line))

    (git-eob)
    rm-list))

;;;###autoload
(defun git-revert (dry-run)
  (interactive "P")

  (let ((buf (tmp-buffer-create "*git revert*"))
	checkout-list rm-list)

    ;; Get the reset out of the way
    (unless (eq 0 (call-process "git" nil nil nil "reset" "HEAD"))
      (error "git reset failed."))

    ;; Get the status
    (unless (eq 0 (call-process "git" nil buf nil "status"))
      (error "git status failed."))

    (save-current-buffer
      (set-buffer buf)
      (goto-char (point-min))
      (setq git-lineno 1)

      ;; Get this out of the way
      (unless (looking-at "# On branch ") (git-bad-line))
      (git-next-line)

      ;; Handle status message
      (when (looking-at "# Your branch is")
	(git-next-line)
	(unless (looking-at "#$") (error "Hmm, expected empty comment line"))
	(git-next-line))

      ;; Parse the output
      (while (not (eobp))
	(cond
	 ((looking-at "# Changes not staged for commit:")
	  (setq checkout-list (append checkout-list (git-parse-not-staged))))

	 ((looking-at "# Untracked files")
	  (setq rm-list (append rm-list (git-parse-untracked))))

	 ((looking-at "no changes added to commit") nil)
	 ((looking-at "nothing added to commit but untracked files") nil)

	 (t (git-bad-line)))
	(git-next-line))

      ) ;; return the previous buffer to get correct directory

    (if t ;; Set to nil for debugging
	(kill-buffer buf) ;; Done with it
      ;; For debugging
      (message "checkout %S" checkout-list)
      (message "rm %S" rm-list))

    ;; Do it!
    (dolist (file checkout-list)
      (if dry-run
	  (message "git checkout %s" file)
	(unless (eq 0 (call-process "git" nil nil nil "checkout" file))
	  (message "Checkout %s failed." file))))

    (dolist (file rm-list)
      (if (string-match "/$" file)
	  ;; Directory
	  (if dry-run
	      (message "rm -rf %s" file)
	    (unless (eq 0 (call-process "rm" nil nil nil "-r" file))
	      (message "rm -r %s failed." file)))
	;; File
	(if dry-run
	    (message "rm %s" file)
	  (delete-file file))))
    ))

(provide 'git-revert)
