;;; tmp-buffer.el --- Create unique tmp buffers with timeout.

;; Copyright (C) 2011 Sean MacLennan

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License version
;; 2 as published by the Free Software Foundation.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABIL`ITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

(eval-when-compile (require 'sam-common))

(my-feature-cond
  (emacs (eval-when-compile (require 'itimer))))

(defvar tbc-func 'tbc-name-func
  "* The function used to create unique buffer names.
It is passed three arguments: name, base, and count.

The first arg is just the unmodified name from the caller.

The base arg is a normalized name. If name is of the type '*name*' then
the asterisks (*) are removed. If it is a filename, the directory path
is removed.

Count will always be nil on the first call. After that it will be an
increasing number starting at 1.")

(defvar tbc-timeout 3600
  "* Delete a buffer if it is more than `tbc-timeout' seconds old.")

(defvar tbc-interval 60
  "* Check the buffers when idle for `tbc-interval' seconds.")

(defvar tbc-list nil
  "List of tmp buffers. Each entry is: buffer expires timeout arg.")

(defvar tbc-timer nil
  "The timer to check for buffer timeouts.")


(defun tbc-name-func (name base count)
  "The default `tbc-func' function."
  (if count
      (concat "*" base "-{" (number-to-string count) "}*")
    (concat "*" base "*")))

;;;###autoload
(defun tmp-buffer-name (name &optional reuse)
  "Create a unique buffer name.
Don't create the buffer or add it to the list."
  (let (base bufname)
    (if (string-match "^*\\(.*\\)\\*$" name) ;; *name*
	(setq base (match-string 1 name))
      ;; assume filename - nop for other simple names
      (setq base (file-name-nondirectory name)))

    (setq bufname (apply tbc-func name base nil nil))
    (unless reuse
      (if (get-buffer bufname)
	  (do ((count 1 (1+ count))) ((not (get-buffer bufname)) t)
	    (setq bufname (apply tbc-func name base count nil)))))

    bufname))

;;;###autoload
(defun tmp-buffer-create (name &optional reuse timeout arg)
  "Create a unique tmp buffer based on `name'.

If reuse is non-nil, then reuse the buffer if it exists.
If timeout is non-nil, then it specifies a timeout in seconds.
If timeout is not an integer, then it defaults to `tbc-timeout'.
The optional argument `arg' is just stored with the buffer in the `tbc-list'.

The function pointed to by `tbc-func' is used to create the buffer name."
  (let* ((bufname (tmp-buffer-name name reuse))
	 (buf (get-buffer-create bufname))
	 expires)

    ;; bufname in list, remove it
    ;; remove dead buffers while we are at it
    (dolist (tbc tbc-list)
      (if (buffer-live-p (car tbc))
	  (if (equal bufname (buffer-name (car tbc)))
	      (setq tbc-list (delq tbc tbc-list)))
	(setq tbc-list (delq tbc tbc-list))))

    ;; Deal with timeout
    (when timeout
      (unless (integerp timeout) (setq timeout tbc-timeout))
      (setq expires (time-add (current-time) (list 0 timeout 0))))

    ;; Append new item
    (setq tbc-list (append tbc-list (list (list buf expires timeout arg))))

    ;; Start the timer if needed
    (unless tbc-timer
      (setq tbc-timer
	    (start-itimer "tbc cleanup" 'tbc-check-buffers tbc-interval tbc-interval t)))

    buf))

;;;###autoload
(defun tmp-buffer-reap (&optional arg)
  "Cleanup the tbc-list.
Remove all killed buffers from list. If arg is non-nil, remove buffers that
match arg."
  (interactive)

  ;; Reap dead buffers
  (dolist (tbc tbc-list)
    (unless (buffer-live-p (car tbc))
      (when (interactive-p) (message "Reap %S" (car tbc)))
      (setq tbc-list (delq tbc tbc-list))))

  ;; If arg non-nil, match that
  (when arg
    (dolist (tbc tbc-list)
      (when (equal arg (nth 3 tbc))
	(when (interactive-p) (message "Kill %S" (car tbc)))
	(kill-buffer (car tbc))
	(setq tbc-list (delq tbc tbc-list)))))
  )

(my-feature-cond
  (emacs (defalias 'windows-of-buffer 'get-buffer-window-list)))

(defun tbc-check-timeout (tbc now)
  (let ((buf (car tbc)) expires)
    (if (windows-of-buffer buf 'no t)
	(progn ;; Visible - update timeout
	  (setq expires (time-add now (list 0 (nth 2 tbc) 0)))
	  (setcdr tbc (cons expires (cddr tbc))))
      (and (not (buffer-modified-p buf))
	   (time-less-p (nth 1 tbc) now)
	   (kill-buffer buf)
	   (setq tbc-list (delq tbc tbc-list)))
      )))

(defun tbc-check-buffers ()
  "Check buffers for timeouts. Meant to be called from `tbc-timer'."
  (let ((now (current-time)))

    (dolist (tbc tbc-list)
      (if (buffer-live-p (car tbc))
	  (when (nth 2 tbc)
	    (tbc-check-timeout tbc now))
	;; Buffer dead - remove entry
	(setq tbc-list (delq tbc tbc-list))))
    )

  (if tbc-list
      ;; Check if we need to update restart time
      (unless (eq (itimer-restart tbc-timer) tbc-interval)
	(set-itimer-restart tbc-timer tbc-interval))
    ;; Disable
    (delete-itimer tbc-timer);
    (setq tbc-timer nil))
  )

(provide 'tmp-buffer)
