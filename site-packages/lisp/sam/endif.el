;; Copyright (C) 2010 Sean MacLennan

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

(eval-when-compile
  (unless (featurep 'xemacs) (require 'extent)))

(defvar endif-sol-re "^[ \t]*#[ \t]*"
  "* Start of line... used in all the rest of the re's.")

(defvar endif-if-re (concat endif-sol-re "if")
  "* Match an if.")

(defvar endif-else-re (concat endif-sol-re "el\\(se\\|if\\)\\>")
  "* Match an else.")

(defvar endif-end-re (concat endif-sol-re "endif\\>")
  "* Match an end.")

(defvar endif-highlight t
  "* If non-nil, the endif-* functions always highlight.")

(defgroup endif-highlighting nil
  "Group for highlighting in endif."
  :prefix "endif-"
  :group 'endif)

(defface endif-face
  '((((class color))  (:background "pale green"))
    (t (:reverse t)))
  "Face for endif hightlighting"
  :group 'endif-highlighting)

;; SAM Buffer local rather than list?
(defvar endif-list nil "Don't touch this! List of (buffer extent tick).")

(defun endif-error (saved-point errstr)
  (endif-stop)
  (goto-char saved-point)
  (error errstr))

;;;###autoload
(defun endif-goto (highlight)
  "Goto the endif that matches the current if block."
  (interactive "P")
  (let ((saved-point (point)) start (nesting 1))
    (end-of-line)
    (unless (re-search-backward endif-if-re nil t)
      (endif-error saved-point "Start of block not found."))

    (setq start (point))

    (while (and (> nesting 0) (not (eobp)))
      (forward-line)
      (if (looking-at endif-end-re)
	  (progn
	    (setq nesting (1- nesting)))
	(if (looking-at endif-if-re)
	    (setq nesting (1+ nesting)))))

    (when (> nesting 0)
      (endif-error saved-point "No matching endif."))

    (unless (and (>= saved-point start) (< saved-point (point)))
      (endif-error saved-point "Not in an if/endif block."))

    (end-of-line) (forward-char)

    (if (or highlight endif-highlight)
	(endif-highlight start)
      (endif-stop))
    ))

;;;###autoload
(defun endif-next-if (highlight)
  "Goto the next if and possibly highlight it."
  (interactive "P")
  (if (eq highlight nil)
      (setq highlight endif-highlight)
    (when (listp highlight) ;; if prefix arg present
      (setq highlight t)))
  (forward-char)
  (when (re-search-forward endif-if-re)
    (beginning-of-line)
    (when (eq highlight t)
      (save-excursion
	(endif-goto t)))))

;;;###autoload
(defun endif-prev-if (highlight)
  "Goto previous if and optionally highlight it."
  (interactive "P")
  (if (eq highlight nil)
      (setq highlight endif-highlight)
    (when (listp highlight) ;; if prefix arg present
      (setq highlight t)))
  (when (re-search-backward endif-if-re)
    (beginning-of-line)
    (when (eq highlight t)
      (save-excursion
	(endif-goto t)))))

(defun endif-find-buffer ()
  (assoc (current-buffer) endif-list))

(defun endif-highlight (start)
  (save-excursion
    (let ((list (endif-find-buffer))
	  extent)
      (if list
	  ;; Everything setup - just update the extent region
	  (set-extent-endpoints (nth 1 list) start (point))
	;; Create a new extent and add it to the list
	(setq extent (make-extent start (point)))
	(set-extent-face extent 'endif-face)
	(setq list (list (current-buffer) extent (buffer-modified-tick)))
	(add-to-list 'endif-list list)
	(add-hook 'post-command-hook 'endif-post-command)))))

(defun endif-stop ()
  (interactive)
  (let ((list (endif-find-buffer)))
    (when list
      (setq endif-list (delete list endif-list))
      (delete-extent (nth 1 list))))

  ;; paranoia - reap dead extents
  (dolist (entry endif-list)
    (unless (extent-live-p (nth 1 entry))
      (setq endif-list (delete entry endif-list))))

  (unless endif-list
    (remove-hook 'post-command-hook 'endif-post-command)))

(defun endif-post-command ()
  (let ((list (endif-find-buffer)))
    (and list
	 (not (eq (buffer-modified-tick) (nth 2 list)))
	 (endif-stop))))

(provide 'endif)
